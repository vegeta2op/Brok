"""Access control and authorization testing module"""

from typing import List, Dict, Any
from urllib.parse import urljoin
from .base import BasePentestModule
from ..models import Vulnerability, VulnerabilityType, SeverityLevel
import re


class AccessControlModule(BasePentestModule):
    """Access control vulnerability detection"""
    
    def get_module_name(self) -> str:
        return "Access Control"
    
    async def scan(self, url: str, context: Dict[str, Any] = None) -> List[Vulnerability]:
        """Scan for access control vulnerabilities"""
        self.vulnerabilities = []
        
        # Test for IDOR (Insecure Direct Object References)
        await self.test_idor(url)
        
        # Test for forced browsing
        await self.test_forced_browsing(url)
        
        # Test for missing function level access control
        await self.test_function_level_access(url)
        
        return self.vulnerabilities
    
    async def test_idor(self, url: str):
        """Test for Insecure Direct Object References"""
        # Look for numeric IDs in URL
        id_pattern = r'/(\d+)(/|$)'
        match = re.search(id_pattern, url)
        
        if match:
            original_id = match.group(1)
            
            # Try to access adjacent IDs
            test_ids = [
                str(int(original_id) + 1),
                str(int(original_id) - 1),
                "1",
                "999999"
            ]
            
            original_response = await self.make_request(url)
            if not original_response or original_response.status_code != 200:
                return
            
            for test_id in test_ids[:2]:  # Test only 2 IDs to be respectful
                test_url = url.replace(f"/{original_id}", f"/{test_id}")
                
                await self.rate_limit()
                test_response = await self.make_request(test_url)
                
                if test_response and test_response.status_code == 200:
                    # Check if response is substantially different (not just ID change)
                    if len(test_response.text) > 100:  # Has actual content
                        self.create_vulnerability(
                            vuln_type=VulnerabilityType.BROKEN_ACCESS,
                            severity=SeverityLevel.HIGH,
                            title="Potential IDOR (Insecure Direct Object Reference)",
                            description="Sequential IDs can be accessed without proper authorization checks",
                            affected_url=url,
                            evidence=f"Original URL: {url}\nAccessible URL: {test_url}\nBoth return 200 OK",
                            reproduction_steps=[
                                f"1. Access {url} (original resource)",
                                f"2. Modify ID to {test_id}",
                                f"3. Access {test_url}",
                                "4. Observe that other user's resource is accessible"
                            ],
                            remediation="Implement proper authorization checks. Verify that the authenticated user has permission to access the requested resource. Use indirect references or add authorization middleware.",
                            cwe_id="CWE-639",
                            cvss_score=7.5
                        )
                        return
    
    async def test_forced_browsing(self, base_url: str):
        """Test for forced browsing / predictable resource location"""
        # Common admin/sensitive paths
        sensitive_paths = [
            "/admin",
            "/administrator",
            "/admin.php",
            "/admin/",
            "/admin/index.php",
            "/wp-admin/",
            "/administrator/",
            "/moderator/",
            "/controlpanel/",
            "/user/1",
            "/api/users",
            "/api/admin"
        ]
        
        accessible_paths = []
        
        for path in sensitive_paths[:5]:  # Test first 5
            url = urljoin(base_url, path)
            await self.rate_limit()
            response = await self.make_request(url, follow_redirects=False)
            
            # Check if accessible without auth (200, 301, or 403 indicates existence)
            if response and response.status_code in [200, 301, 302]:
                accessible_paths.append(path)
        
        if accessible_paths:
            self.create_vulnerability(
                vuln_type=VulnerabilityType.BROKEN_ACCESS,
                severity=SeverityLevel.MEDIUM,
                title="Predictable Resource Location / Forced Browsing",
                description="Sensitive administrative paths are accessible or discoverable",
                affected_url=base_url,
                evidence=f"Accessible paths: {', '.join(accessible_paths)}",
                reproduction_steps=[
                    f"1. Navigate to {urljoin(base_url, accessible_paths[0])}",
                    "2. Observe the page is accessible without authentication",
                    "3. Administrative functions may be exposed"
                ],
                remediation="Implement proper authentication and authorization. Don't rely on obscurity. Use role-based access control.",
                cwe_id="CWE-425"
            )
    
    async def test_function_level_access(self, url: str):
        """Test for missing function-level access control"""
        # This would typically require authentication context
        # For now, check for API endpoints that might lack proper access control
        
        if "/api/" in url or url.endswith(".json"):
            response = await self.make_request(url)
            
            if response and response.status_code == 200:
                # Check if it looks like sensitive API data
                content = response.text.lower()
                
                sensitive_keywords = [
                    "password", "token", "secret", "api_key", "private",
                    "ssn", "credit_card", "admin", "role", "permission"
                ]
                
                found_sensitive = [kw for kw in sensitive_keywords if kw in content]
                
                if found_sensitive:
                    self.create_vulnerability(
                        vuln_type=VulnerabilityType.BROKEN_ACCESS,
                        severity=SeverityLevel.HIGH,
                        title="Potential Sensitive Data Exposure in API",
                        description="API endpoint exposes potentially sensitive information without authentication",
                        affected_url=url,
                        evidence=f"Endpoint accessible without auth. Contains: {', '.join(found_sensitive)}",
                        reproduction_steps=[
                            f"1. Access {url} without authentication",
                            "2. Observe sensitive data in response",
                            "3. No authorization required"
                        ],
                        remediation="Implement proper authentication and authorization for all API endpoints. Use OAuth2 or JWT tokens. Validate user permissions before returning data.",
                        cwe_id="CWE-862",
                        cvss_score=7.5
                    )

