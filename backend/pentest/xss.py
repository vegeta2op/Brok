"""Cross-Site Scripting (XSS) detection module"""

from typing import List, Dict, Any
from urllib.parse import urljoin, parse_qs, urlparse, urlencode
from bs4 import BeautifulSoup
from .base import BasePentestModule
from ..models import Vulnerability, VulnerabilityType, SeverityLevel
import re


class XSSModule(BasePentestModule):
    """XSS vulnerability detection"""
    
    # XSS test payloads
    XSS_PAYLOADS = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<iframe src=javascript:alert('XSS')>",
        "'><script>alert('XSS')</script>",
        "\"><script>alert('XSS')</script>",
        "<body onload=alert('XSS')>",
        "<input onfocus=alert('XSS') autofocus>",
        "<marquee onstart=alert('XSS')>"
    ]
    
    # Markers for reflected content
    MARKERS = [
        "XSS_TEST_MARKER_12345",
        "unique_xss_marker_99999"
    ]
    
    def get_module_name(self) -> str:
        return "Cross-Site Scripting (XSS)"
    
    async def scan(self, url: str, context: Dict[str, Any] = None) -> List[Vulnerability]:
        """Scan for XSS vulnerabilities"""
        self.vulnerabilities = []
        
        # Test reflected XSS in URL parameters
        await self.test_reflected_xss(url)
        
        # Test forms for XSS
        if context and "forms" in context:
            for form in context["forms"]:
                await self.test_form_xss(url, form)
        
        return self.vulnerabilities
    
    async def test_reflected_xss(self, url: str):
        """Test for reflected XSS in URL parameters"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return
        
        for param_name in params.keys():
            # First, test with a unique marker to see if input is reflected
            marker = self.MARKERS[0]
            test_params = params.copy()
            test_params[param_name] = [marker]
            
            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
            
            await self.rate_limit()
            response = await self.make_request(test_url)
            
            if not response:
                continue
            
            # Check if marker is reflected
            if marker in response.text:
                # Input is reflected, now test with XSS payloads
                for payload in self.XSS_PAYLOADS[:3]:
                    test_params[param_name] = [payload]
                    xss_test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                    
                    await self.rate_limit()
                    xss_response = await self.make_request(xss_test_url)
                    
                    if xss_response and self.detect_xss(payload, xss_response.text):
                        self.create_vulnerability(
                            vuln_type=VulnerabilityType.XSS,
                            severity=SeverityLevel.HIGH,
                            title=f"Reflected XSS in URL Parameter '{param_name}'",
                            description=f"The parameter '{param_name}' is vulnerable to reflected cross-site scripting",
                            affected_url=url,
                            evidence=f"Parameter: {param_name}\nPayload: {payload}\nPayload reflected without proper encoding",
                            reproduction_steps=[
                                f"1. Navigate to {url}",
                                f"2. Modify parameter '{param_name}' to: {payload}",
                                "3. Observe the payload is executed or improperly encoded in the response",
                                "4. JavaScript code can be executed in the context of the application"
                            ],
                            remediation="Implement proper output encoding/escaping. Use Content Security Policy (CSP). Validate and sanitize all user inputs. Use frameworks that auto-escape by default.",
                            cwe_id="CWE-79",
                            cvss_score=7.1
                        )
                        return  # Found XSS, move to next parameter
    
    async def test_form_xss(self, base_url: str, form: Dict[str, Any]):
        """Test form inputs for XSS"""
        action = form.get("action", "")
        method = form.get("method", "GET").upper()
        inputs = form.get("inputs", [])
        
        if not inputs:
            return
        
        form_url = urljoin(base_url, action) if action else base_url
        
        # Test each input field
        for input_field in inputs:
            input_name = input_field.get("name")
            input_type = input_field.get("type", "text")
            
            if not input_name or input_type in ["submit", "button", "hidden"]:
                continue
            
            await self.rate_limit()
            
            # First test with marker
            form_data = {inp.get("name"): inp.get("value", "") for inp in inputs if inp.get("name")}
            marker = self.MARKERS[0]
            form_data[input_name] = marker
            
            if method == "POST":
                response = await self.make_request(form_url, method="POST", data=form_data)
            else:
                response = await self.make_request(form_url, method="GET", params=form_data)
            
            if not response or marker not in response.text:
                continue
            
            # Input is reflected, test with XSS payloads
            for payload in self.XSS_PAYLOADS[:3]:
                form_data[input_name] = payload
                
                await self.rate_limit()
                
                if method == "POST":
                    xss_response = await self.make_request(form_url, method="POST", data=form_data)
                else:
                    xss_response = await self.make_request(form_url, method="GET", params=form_data)
                
                if xss_response and self.detect_xss(payload, xss_response.text):
                    self.create_vulnerability(
                        vuln_type=VulnerabilityType.XSS,
                        severity=SeverityLevel.HIGH,
                        title=f"XSS in Form Input '{input_name}'",
                        description=f"The form field '{input_name}' is vulnerable to cross-site scripting",
                        affected_url=form_url,
                        evidence=f"Form: {form_url}\nField: {input_name}\nPayload: {payload}",
                        reproduction_steps=[
                            f"1. Navigate to {base_url}",
                            f"2. Find form with action '{action}'",
                            f"3. Enter payload in field '{input_name}': {payload}",
                            "4. Submit the form",
                            "5. Observe the XSS payload in the response"
                        ],
                        remediation="Implement proper output encoding for all user-supplied data. Use Content Security Policy. Validate inputs and use safe APIs.",
                        cwe_id="CWE-79",
                        cvss_score=7.1
                    )
                    return
    
    def detect_xss(self, payload: str, response_text: str) -> bool:
        """Detect if XSS payload was successfully reflected without encoding"""
        # Check if the payload appears unencoded in the response
        # This is a simplified check
        
        # Remove spaces and compare
        payload_normalized = payload.replace(" ", "").lower()
        response_normalized = response_text.replace(" ", "").lower()
        
        if payload_normalized in response_normalized:
            return True
        
        # Check for common XSS patterns in response
        xss_patterns = [
            r"<script[^>]*>.*?alert",
            r"onerror\s*=",
            r"onload\s*=",
            r"javascript:",
            r"<iframe[^>]*src\s*=\s*['\"]?javascript:"
        ]
        
        for pattern in xss_patterns:
            if re.search(pattern, response_text, re.IGNORECASE | re.DOTALL):
                return True
        
        return False
    
    async def test_dom_xss(self, url: str):
        """Test for DOM-based XSS (would require browser automation)"""
        # This would require Playwright or similar
        # Placeholder for future implementation
        pass

