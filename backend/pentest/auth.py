"""Authentication and session management testing module"""

from typing import List, Dict, Any
from urllib.parse import urljoin
from .base import BasePentestModule
from ..models import Vulnerability, VulnerabilityType, SeverityLevel


class AuthenticationModule(BasePentestModule):
    """Authentication and session security testing"""
    
    def get_module_name(self) -> str:
        return "Authentication & Session Management"
    
    async def scan(self, url: str, context: Dict[str, Any] = None) -> List[Vulnerability]:
        """Scan for authentication vulnerabilities"""
        self.vulnerabilities = []
        
        # Check for weak session cookies
        await self.check_session_cookies(url)
        
        # Check for password reset vulnerabilities
        await self.check_password_reset(url, context)
        
        # Check for login form over HTTP
        await self.check_insecure_login(url, context)
        
        return self.vulnerabilities
    
    async def check_session_cookies(self, url: str):
        """Check session cookie security"""
        response = await self.make_request(url)
        
        if not response:
            return
        
        set_cookie_headers = response.headers.get_list("set-cookie")
        
        for cookie in set_cookie_headers:
            cookie_lower = cookie.lower()
            
            # Identify session cookies
            is_session_cookie = any(name in cookie_lower for name in 
                                   ["session", "auth", "token", "jsessionid", "phpsessid"])
            
            if is_session_cookie:
                cookie_name = cookie.split("=")[0] if "=" in cookie else "unknown"
                issues = []
                
                # Check for HttpOnly flag
                if "httponly" not in cookie_lower:
                    issues.append("Missing HttpOnly flag (vulnerable to XSS)")
                
                # Check for Secure flag
                if "secure" not in cookie_lower and url.startswith("https"):
                    issues.append("Missing Secure flag (can be sent over HTTP)")
                
                # Check for SameSite
                if "samesite" not in cookie_lower:
                    issues.append("Missing SameSite attribute (vulnerable to CSRF)")
                
                if issues:
                    self.create_vulnerability(
                        vuln_type=VulnerabilityType.BROKEN_AUTH,
                        severity=SeverityLevel.MEDIUM,
                        title=f"Insecure Session Cookie: {cookie_name}",
                        description=f"Session cookie has security issues: {', '.join(issues)}",
                        affected_url=url,
                        evidence=f"Cookie: {cookie_name}\nIssues: {', '.join(issues)}",
                        reproduction_steps=[
                            f"1. Visit {url}",
                            "2. Inspect Set-Cookie headers",
                            f"3. Note cookie '{cookie_name}' lacks: {', '.join(issues)}"
                        ],
                        remediation="Set HttpOnly, Secure, and SameSite attributes on all session cookies.",
                        cwe_id="CWE-614"
                    )
    
    async def check_password_reset(self, base_url: str, context: Dict[str, Any] = None):
        """Check for password reset functionality"""
        # Common password reset endpoints
        reset_paths = [
            "/forgot-password",
            "/reset-password",
            "/password/reset",
            "/account/password-reset",
            "/user/password/forgot"
        ]
        
        for path in reset_paths:
            url = urljoin(base_url, path)
            await self.rate_limit()
            response = await self.make_request(url)
            
            if response and response.status_code == 200:
                # Found a password reset page
                # Check if it's over HTTP
                if url.startswith("http://"):
                    self.create_vulnerability(
                        vuln_type=VulnerabilityType.BROKEN_AUTH,
                        severity=SeverityLevel.HIGH,
                        title="Password Reset Over HTTP",
                        description="Password reset functionality is accessible over unencrypted HTTP",
                        affected_url=url,
                        evidence=f"Password reset page found at: {url}",
                        reproduction_steps=[
                            f"1. Navigate to {url}",
                            "2. Note the page is served over HTTP",
                            "3. Password reset tokens can be intercepted"
                        ],
                        remediation="Enforce HTTPS for all authentication-related pages. Implement HSTS.",
                        cwe_id="CWE-319",
                        cvss_score=7.5
                    )
                break
    
    async def check_insecure_login(self, base_url: str, context: Dict[str, Any] = None):
        """Check if login forms are served over HTTP"""
        if not base_url.startswith("http://"):
            return
        
        # Check for login forms
        if context and "forms" in context:
            for form in context["forms"]:
                inputs = form.get("inputs", [])
                
                # Look for password fields
                has_password = any(
                    inp.get("type", "").lower() == "password" 
                    for inp in inputs
                )
                
                if has_password:
                    self.create_vulnerability(
                        vuln_type=VulnerabilityType.BROKEN_AUTH,
                        severity=SeverityLevel.CRITICAL,
                        title="Login Form Over HTTP",
                        description="Login form with password field is served over unencrypted HTTP",
                        affected_url=base_url,
                        evidence=f"Password field found in form with action: {form.get('action', 'current page')}",
                        reproduction_steps=[
                            f"1. Navigate to {base_url}",
                            "2. Inspect the login form",
                            "3. Note it's served over HTTP",
                            "4. Credentials can be intercepted in transit"
                        ],
                        remediation="Immediately enforce HTTPS for all pages containing authentication forms. Implement HTTP to HTTPS redirection. Enable HSTS.",
                        cwe_id="CWE-319",
                        cvss_score=9.1
                    )
                    return

