"""SQL Injection detection module"""

from typing import List, Dict, Any
from urllib.parse import urljoin, parse_qs, urlparse, urlencode
from bs4 import BeautifulSoup
from .base import BasePentestModule
from ..models import Vulnerability, VulnerabilityType, SeverityLevel
import re


class SQLInjectionModule(BasePentestModule):
    """SQL Injection vulnerability detection"""
    
    # SQL injection payloads
    SQL_PAYLOADS = [
        "'",
        "\"",
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' /*",
        "admin' --",
        "admin' #",
        "' UNION SELECT NULL--",
        "1' AND '1'='2",
        "1 AND 1=1",
        "1 AND 1=2"
    ]
    
    # SQL error patterns
    SQL_ERRORS = [
        r"SQL syntax.*MySQL",
        r"Warning.*mysql_.*",
        r"valid MySQL result",
        r"MySqlClient\.",
        r"PostgreSQL.*ERROR",
        r"Warning.*\Wpg_.*",
        r"valid PostgreSQL result",
        r"Npgsql\.",
        r"Driver.*SQL Server",
        r"OLE DB.*SQL Server",
        r"SQLServer JDBC Driver",
        r"SqlException",
        r"Oracle error",
        r"Oracle.*Driver",
        r"Warning.*\Woci_.*",
        r"Warning.*\Wora_.*",
    ]
    
    def get_module_name(self) -> str:
        return "SQL Injection"
    
    async def scan(self, url: str, context: Dict[str, Any] = None) -> List[Vulnerability]:
        """Scan for SQL injection vulnerabilities"""
        self.vulnerabilities = []
        
        # Test URL parameters
        await self.test_url_parameters(url)
        
        # Test forms if provided in context
        if context and "forms" in context:
            for form in context["forms"]:
                await self.test_form(url, form)
        
        return self.vulnerabilities
    
    async def test_url_parameters(self, url: str):
        """Test URL parameters for SQL injection"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return
        
        for param_name in params.keys():
            await self.rate_limit()
            
            # Test with various payloads
            for payload in self.SQL_PAYLOADS[:5]:  # Test first 5 payloads
                # Create modified URL with payload
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                
                response = await self.make_request(test_url)
                
                if response and self.detect_sql_error(response.text):
                    self.create_vulnerability(
                        vuln_type=VulnerabilityType.SQL_INJECTION,
                        severity=SeverityLevel.CRITICAL,
                        title=f"SQL Injection in URL Parameter '{param_name}'",
                        description=f"The parameter '{param_name}' appears to be vulnerable to SQL injection attacks",
                        affected_url=url,
                        evidence=f"Payload: {payload}\nSQL error detected in response",
                        reproduction_steps=[
                            f"1. Navigate to {url}",
                            f"2. Modify parameter '{param_name}' to: {payload}",
                            "3. Observe SQL error in response",
                            "4. Further exploitation may be possible"
                        ],
                        remediation="Use parameterized queries or prepared statements. Never concatenate user input directly into SQL queries. Implement input validation and use an ORM.",
                        cwe_id="CWE-89",
                        cvss_score=9.8
                    )
                    return  # Found vulnerability, no need to test more payloads for this param
    
    async def test_form(self, base_url: str, form: Dict[str, Any]):
        """Test form inputs for SQL injection"""
        action = form.get("action", "")
        method = form.get("method", "GET").upper()
        inputs = form.get("inputs", [])
        
        if not inputs:
            return
        
        # Build form URL
        form_url = urljoin(base_url, action) if action else base_url
        
        # Test each input field
        for input_field in inputs:
            input_name = input_field.get("name")
            if not input_name:
                continue
            
            await self.rate_limit()
            
            # Build form data with SQL payload
            form_data = {inp.get("name"): inp.get("value", "") for inp in inputs if inp.get("name")}
            
            for payload in self.SQL_PAYLOADS[:3]:  # Test first 3 payloads
                form_data[input_name] = payload
                
                if method == "POST":
                    response = await self.make_request(form_url, method="POST", data=form_data)
                else:
                    response = await self.make_request(form_url, method="GET", params=form_data)
                
                if response and self.detect_sql_error(response.text):
                    self.create_vulnerability(
                        vuln_type=VulnerabilityType.SQL_INJECTION,
                        severity=SeverityLevel.CRITICAL,
                        title=f"SQL Injection in Form Input '{input_name}'",
                        description=f"The form field '{input_name}' is vulnerable to SQL injection",
                        affected_url=form_url,
                        evidence=f"Form: {form_url}\nField: {input_name}\nPayload: {payload}",
                        reproduction_steps=[
                            f"1. Navigate to {base_url}",
                            f"2. Find form with action '{action}'",
                            f"3. Enter payload in field '{input_name}': {payload}",
                            "4. Submit the form",
                            "5. Observe SQL error in response"
                        ],
                        remediation="Use parameterized queries for all database operations. Implement proper input validation and sanitization. Use prepared statements.",
                        cwe_id="CWE-89",
                        cvss_score=9.8
                    )
                    return
    
    def detect_sql_error(self, response_text: str) -> bool:
        """Detect SQL error messages in response"""
        for pattern in self.SQL_ERRORS:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True
        return False
    
    async def test_blind_sql_injection(self, url: str):
        """Test for blind SQL injection (time-based)"""
        # This would involve more sophisticated testing
        # For now, we'll keep it simple
        pass

