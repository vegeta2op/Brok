"""Custom Pentesting Tools MCP Server"""

import asyncio
import httpx
from typing import Dict, Any, List
from urllib.parse import urlparse, urljoin
import json


class PentestToolsServer:
    """MCP Server for pentesting tools"""
    
    def __init__(self):
        self.timeout = 30
        self.user_agent = "JimCrow-PenTest-Agent/0.1.0"
    
    async def http_request(
        self,
        url: str,
        method: str = "GET",
        headers: Dict[str, str] = None,
        data: Dict[str, Any] = None,
        params: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Make an HTTP request"""
        try:
            async with httpx.AsyncClient(
                timeout=self.timeout,
                verify=False,
                follow_redirects=True
            ) as client:
                request_headers = {
                    "User-Agent": self.user_agent,
                    **(headers or {})
                }
                
                response = await client.request(
                    method=method,
                    url=url,
                    headers=request_headers,
                    data=data,
                    params=params
                )
                
                return {
                    "status_code": response.status_code,
                    "headers": dict(response.headers),
                    "content": response.text,
                    "url": str(response.url)
                }
        except Exception as e:
            return {
                "error": str(e)
            }
    
    async def test_sql_injection(
        self,
        url: str,
        parameter: str,
        payloads: List[str] = None
    ) -> Dict[str, Any]:
        """Test for SQL injection"""
        if payloads is None:
            payloads = [
                "'",
                "' OR '1'='1",
                "' OR '1'='1' --",
                "1' AND '1'='2"
            ]
        
        results = []
        
        for payload in payloads:
            # Inject payload into URL
            test_url = url.replace(f"{parameter}=", f"{parameter}={payload}")
            
            response = await self.http_request(test_url)
            
            # Check for SQL errors
            sql_errors = [
                "SQL syntax",
                "mysql_fetch",
                "PostgreSQL.*ERROR",
                "ORA-",
                "SQLServer JDBC"
            ]
            
            has_error = any(
                error.lower() in response.get("content", "").lower()
                for error in sql_errors
            )
            
            results.append({
                "payload": payload,
                "status_code": response.get("status_code"),
                "sql_error_detected": has_error
            })
        
        return {
            "url": url,
            "parameter": parameter,
            "tests": results,
            "vulnerable": any(r["sql_error_detected"] for r in results)
        }
    
    async def test_xss(
        self,
        url: str,
        parameter: str,
        payloads: List[str] = None
    ) -> Dict[str, Any]:
        """Test for XSS"""
        if payloads is None:
            payloads = [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')"
            ]
        
        results = []
        
        for payload in payloads:
            test_url = url.replace(f"{parameter}=", f"{parameter}={payload}")
            
            response = await self.http_request(test_url)
            
            # Check if payload is reflected
            reflected = payload in response.get("content", "")
            
            results.append({
                "payload": payload,
                "status_code": response.get("status_code"),
                "reflected": reflected
            })
        
        return {
            "url": url,
            "parameter": parameter,
            "tests": results,
            "vulnerable": any(r["reflected"] for r in results)
        }
    
    async def directory_enumeration(
        self,
        base_url: str,
        wordlist: List[str] = None
    ) -> Dict[str, Any]:
        """Enumerate directories"""
        if wordlist is None:
            wordlist = [
                "admin", "api", "backup", "config", "dashboard",
                "dev", "files", "logs", "test", "uploads"
            ]
        
        found = []
        
        for path in wordlist:
            url = urljoin(base_url, path)
            response = await self.http_request(url)
            
            status = response.get("status_code")
            if status in [200, 301, 302, 403]:
                found.append({
                    "path": path,
                    "url": url,
                    "status_code": status
                })
            
            # Rate limiting
            await asyncio.sleep(0.1)
        
        return {
            "base_url": base_url,
            "found": found,
            "total_tested": len(wordlist)
        }
    
    async def check_security_headers(self, url: str) -> Dict[str, Any]:
        """Check security headers"""
        response = await self.http_request(url)
        
        required_headers = {
            "Strict-Transport-Security": "HSTS",
            "Content-Security-Policy": "CSP",
            "X-Frame-Options": "Clickjacking Protection",
            "X-Content-Type-Options": "Content Type Protection",
            "Referrer-Policy": "Referrer Policy"
        }
        
        headers = response.get("headers", {})
        results = {}
        
        for header, description in required_headers.items():
            results[header] = {
                "present": header in headers,
                "value": headers.get(header, "MISSING"),
                "description": description
            }
        
        return {
            "url": url,
            "headers": results,
            "score": sum(1 for h in results.values() if h["present"])
        }
    
    async def subdomain_enumeration(
        self,
        domain: str,
        wordlist: List[str] = None
    ) -> Dict[str, Any]:
        """Enumerate subdomains"""
        if wordlist is None:
            wordlist = ["www", "mail", "api", "dev", "staging", "admin"]
        
        found = []
        
        for subdomain in wordlist:
            test_domain = f"{subdomain}.{domain}"
            
            try:
                # Simple DNS check (in production, use proper DNS library)
                url = f"http://{test_domain}"
                response = await self.http_request(url)
                
                if response.get("status_code"):
                    found.append({
                        "subdomain": test_domain,
                        "status": "active"
                    })
            except:
                pass
            
            await asyncio.sleep(0.1)
        
        return {
            "domain": domain,
            "found": found,
            "total_tested": len(wordlist)
        }
    
    async def port_scan(self, host: str, ports: List[int] = None) -> Dict[str, Any]:
        """Basic port scanning"""
        if ports is None:
            ports = [80, 443, 8080, 8443, 3000, 3306, 5432, 27017]
        
        open_ports = []
        
        for port in ports:
            try:
                # Simple TCP connection test
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port),
                    timeout=2
                )
                writer.close()
                await writer.wait_closed()
                
                open_ports.append(port)
            except:
                pass
        
        return {
            "host": host,
            "open_ports": open_ports,
            "total_scanned": len(ports)
        }
    
    async def test_authentication(
        self,
        url: str,
        username_field: str,
        password_field: str,
        test_credentials: List[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """Test authentication with common credentials"""
        if test_credentials is None:
            test_credentials = [
                {"username": "admin", "password": "admin"},
                {"username": "admin", "password": "password"},
                {"username": "root", "password": "root"}
            ]
        
        results = []
        
        for creds in test_credentials:
            data = {
                username_field: creds["username"],
                password_field: creds["password"]
            }
            
            response = await self.http_request(url, method="POST", data=data)
            
            # Check if login was successful (simple heuristic)
            success = response.get("status_code") in [200, 302]
            
            results.append({
                "credentials": creds,
                "success": success,
                "status_code": response.get("status_code")
            })
            
            await asyncio.sleep(1)  # Rate limiting
        
        return {
            "url": url,
            "tests": results,
            "vulnerable": any(r["success"] for r in results)
        }

